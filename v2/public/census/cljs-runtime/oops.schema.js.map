{"version":3,"sources":["oops/schema.cljs"],"sourcesContent":["(ns oops.schema\n  \"The code for runtime conversion of selectors to paths. Note: we prefer hand-written loops for performance reasons.\"\n  (:require-macros [oops.schema]\n                   [oops.helpers :refer [unchecked-aget]]\n                   [oops.debug :refer [debug-assert]]\n                   [oops.constants :refer [get-dot-access get-soft-access get-punch-access gen-op-get gen-op-set]]))\n\n; implementation here should mimic static versions in schema.clj\n; for performance reasons we don't reuse the same code on cljs side\n\n; --- path utils ------------------------------------------------------------------------------------------------------------\n\n(def escaped-dot-marker \"####ESCAPED-DOT####\")\n(def re-all-escaped-dots (js/RegExp. \"\\\\\\\\\\\\.\" \"g\"))\n(def re-all-escaped-dot-markers (js/RegExp. \"####ESCAPED-DOT####\" \"g\"))\n\n(defn unescape-modifiers [s]\n  (.replace s #\"^\\\\([?!])\" \"$1\"))\n\n(defn parse-selector-element! [element-str arr]\n  (when-not (empty? element-str)\n    (case (first element-str)\n      \"?\" (do\n            (.push arr (get-soft-access))\n            (.push arr (.substring element-str 1)))\n      \"!\" (do\n            (.push arr (get-punch-access))\n            (.push arr (.substring element-str 1)))\n      (do\n        (.push arr (get-dot-access))\n        (.push arr (unescape-modifiers element-str))))))\n\n(defn unescape-dots [s]\n  (.replace s re-all-escaped-dot-markers \".\"))\n\n(defn parse-selector-string! [selector-str arr]\n  (let [elements-arr (.split (.replace selector-str re-all-escaped-dots escaped-dot-marker) \".\")]\n    (loop [items (seq elements-arr)]\n      (when items\n        (parse-selector-element! (unescape-dots (first items)) arr)\n        (recur (next items))))))\n\n(defn coerce-key-dynamically! [key arr]\n  (let [selector-str (name key)]\n    (parse-selector-string! selector-str arr)))\n\n(defn collect-coerced-keys-into-array! [coll arr]\n  (loop [items (seq coll)]                                                                                                    ; note: items is either a seq or nil\n    (when (some? items)\n      (let [item (-first items)]\n        (if (sequential? item)\n          (collect-coerced-keys-into-array! item arr)\n          (coerce-key-dynamically! item arr))\n        (recur (next items))))))\n\n(defn standalone-modifier? [arr i]\n  (and (pos? (unchecked-aget arr i))\n       (= \"\" (unchecked-aget arr (inc i)))))\n\n(defn merge-standalone-modifier! [arr i]\n  (aset arr (+ i 2) (unchecked-aget arr i))                                                                                   ; transfer modifier\n  (.splice arr i 2))                                                                                                          ; remove standalone item\n\n(defn merge-standalone-modifiers! [arr]\n  (let [len (alength arr)]\n    (loop [i (- len 2)]                                                                                                       ; -2 because it makes no sense to potentially merge last item\n      (let [finger (- i 2)]\n        (if (neg? finger)\n          arr\n          (do\n            (when (standalone-modifier? arr finger)\n              (merge-standalone-modifier! arr finger))\n            (recur finger)))))))\n\n(defn prepare-path! [selector arr]\n  (collect-coerced-keys-into-array! selector arr)\n  (merge-standalone-modifiers! arr))\n\n(defn prepare-simple-path! [key arr]\n  (coerce-key-dynamically! key arr))\n\n(defn has-invalid-path-access-mode? [path is-valid?]\n  (loop [items (seq path)]\n    (when items\n      (if (is-valid? (first items))\n        (recur (next (next items)))\n        true))))\n\n; we should mimic check-static-path! here\n(defn check-dynamic-path! [path op]\n  (debug-assert (= (gen-op-get) 0))\n  (debug-assert (= (gen-op-set) 1))\n  (if (empty? path)\n    [:unexpected-empty-selector]\n    (case op\n      0 (when (has-invalid-path-access-mode? path #(not= % (get-punch-access)))\n          [:unexpected-punching-selector])\n      1 (when (has-invalid-path-access-mode? path #(not= % (get-soft-access)))\n          [:unexpected-soft-selector]))))\n"],"mappings":"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","names":["oops.schema/escaped-dot-marker","oops.schema/re-all-escaped-dots","js/RegExp","oops.schema/re-all-escaped-dot-markers","oops.schema/unescape-modifiers","s","oops.schema/parse-selector-element!","cljs.core/empty?","element-str","G__11757","cljs.core/first","arr","oops.schema/unescape-dots","oops.schema/parse-selector-string!","selector-str","cljs.core/seq","elements-arr","items","cljs.core/next","oops.schema/coerce-key-dynamically!","cljs.core/name","key","oops.schema/collect-coerced-keys-into-array!","coll","cljs.core/-first","cljs.core/sequential?","item","oops.schema/standalone-modifier?","i","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","oops.schema/merge-standalone-modifier!","oops.schema/merge-standalone-modifiers!","len","finger","oops.schema/prepare-path!","selector","oops.schema/prepare-simple-path!","oops.schema/has-invalid-path-access-mode?","path","G__11786","is-valid?","oops.schema/check-dynamic-path!","G__11789","js/Error","op","p1__11787#","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","p1__11788#"]}