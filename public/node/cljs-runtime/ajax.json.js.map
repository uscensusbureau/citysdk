{"version":3,"file":"ajax.json.js","sources":["ajax/json.cljc"],"mappings":";;;;AAmBU,8BAAA,9BAAM4B,oEAAmBrB;AACvB,OAAYF,eAAQ,AAACC,qBAAQC,3CAD/B;;AAOA,6BAAA,7BAAMM,kEAAkBT,IAAIK,gBAAUE;AACjC,IAAMD,aAAW,AAAQL,WAAQM,5BADtC;AACK,AACK,oBAAIP;AACAM;;AACA,8HAAA,vHAACqB,0DAAQrB,wIAA4BD;;;AAE7D,qCAAA,rCAAMc,kFAA0BC;AAAhC,AACE;AAAA,AAAA,kDAAA,mEAAA,qEAAA,hFACYA;;;AAaH,yBAAA,zBAAMC,0DAAsBJ,OAAOV;AACjC,oBAAI,iBAAAS,oBAAKC,zDADX;AACM,AAAA,oBAAAD;AAAY,oDAAA,7CAACE,iDAAI,AAAUX,aAAKU;;AAAhCD;;;AACF,OAAYT,eAAK,AAAUU;;AAC3BV;;;AAEf,sCAAA,tCAAMgB,oFAA2BxB;AAAjC,AAAA;AAEE;;;AACM,gGAAA,zFAACS,PADP;;+EAAAE;AAAA,AAAA,IAAAC,aAAAD;IAAAC,iBAAA,EAAA,EAAA,EAAA,CAAAA,cAAA,QAAA,EAAA,EAAA,CAAA,AAAAA,iDAAA,WAAA,CAAAC,gCAAA,AAAAD,+BAAA,KAAA,OAAA,QAAA,AAAAE,8CAAAC,mBAAAH,YAAAA;aAAA,AAAAI,4CAAAJ,eAAA,pEAEYM;sBAFZ,AAAAF,4CAAAJ,eAAA,7EAEmBN;UAFnB,AAAAU,4CAAAJ,eAAA,jEAE6BX;gJAEhB,hJAJb,AAGK,gDAAA,2CAAA,pFAACyB;wGACsCrB;AAClC,IAAAR,WAAWI,fADR;IACHH,WACWQ;IADXP,WAEW,AAACuB,uBAAaJ,OAAO,AAACK,qBAAMlB;AAFvC,AAAA,0FAAAR,SAAAC,SAAAC,gCAAAF,SAAAC,SAAAC,tJAACC,0CAAAA,sEAAAA;;qEAGS,CAAA,+MAEG,mCAAA,cAAA,/BAAIM,tSAPtB,sVAAA,qEAAA,mFAAA,tXAMkB,yGAAA,vFAAIY,QAAO,CAAA,gEAAA,RAAiBA;;sEATnDP;;;;;+EAAAA;;;;;;;;;AAaF;;;;;;;;;;qEAU0CD,pCADtC,AAACc,jCATAK;mEAcsCJ,nEAF3C,AAAKE,gCACD,AAACP","names":["G__23852","G__23853","G__23854","read-json","raw","js/JSON","cljs.core/clj->js","data","xhrio","keywords?","result-raw","text","ajax$json$make_json_response_format_$_json_response_format.cljs$core$IFn$_invoke$arity$1","ajax.json/read-json-native","p__23849","map__23850","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","and__3938__auto__","prefix","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","ajax.json/make-json-request-format","write-json","ajax.json/strip-prefix","ajax.protocols/-body","ajax.json/make-json-response-format","ajax.json/write-json-native","ajax.interceptors/map->ResponseFormat","ajax.json/json-request-format","cljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$variadic","ajax.json/json-response-format"],"sourcesContent":["(ns ajax.json\n  (:require [ajax.interceptors :refer \n                [map->ResponseFormat]]\n            [ajax.protocols :refer\n                [-body -process-request -process-response -abort -status\n                -get-response-header -status-text -js-ajax-request\n                -was-aborted]]\n            #?@ (:clj  [[cheshire.core :as c]\n                        [clojure.java.io :as io]]))\n  #? (:clj (:import [java.io OutputStreamWriter ByteArrayOutputStream\n                InputStreamReader Closeable OutputStream\n                InputStream])))\n\n;;; NB If you're looking to use the google closure JSON implementation,\n;;; You'll need ajax.goog-json instead\n\n#? (:clj (defn write-json-cheshire [stream data]\n           (c/generate-stream data (io/writer stream))))\n\n#? (:cljs (defn write-json-native [data]\n            (.stringify js/JSON (clj->js data))))\n\n#? (:clj (defn read-json-cheshire [raw keywords? text]\n           ; NB Raw is ignored since it makes no sense in this context\n           (c/parse-stream (io/reader text) keywords?)))\n\n#? (:cljs (defn read-json-native [raw keywords? text]\n               (let [result-raw (.parse js/JSON text)]\n                    (if raw\n                        result-raw\n                        (js->clj result-raw :keywordize-keys keywords?)))))\n\n(defn make-json-request-format [write-json]\n  (fn json-request-format []\n      {:write write-json\n       :content-type \"application/json\"}))\n\n#? (:clj (defn strip-prefix\n           ^InputStream [^String prefix ^InputStream text]\n           (if prefix\n             (let [utf8 (.getBytes prefix \"UTF-8\")]\n               (loop [i 0]\n                 (if (and (< i (alength utf8))\n                          (= (aget utf8 i) (.read text)))\n                   (recur (inc i))\n                   text)))\n             text))\n     :cljs (defn strip-prefix [^String prefix text]\n             (if (and prefix (= 0 (.indexOf text prefix)))\n               (.substring text (.-length prefix))\n               text)))\n\n(defn make-json-response-format [read-json]\n  \"Create a json request format given `read-json` function.\"\n  (fn json-response-format\n    ([] (json-response-format {}))\n    ([{:keys [prefix keywords? raw]}]\n       (map->ResponseFormat\n        {:read (fn json-read-response-format [xhrio] \n            (read-json raw\n                       keywords?\n                       (strip-prefix prefix (-body xhrio))))\n         :description (str \"JSON\"\n                         (if prefix (str \" prefix '\" prefix \"'\"))\n                         (if keywords? \" keywordize\"))\n         :content-type [\"application/json\"]}))))\n\n(def json-response-format\n  \"Returns a JSON response format using the native JSON \n   implementation. Options include\n   :keywords? Returns the keys as keywords\n   :prefix A prefix that needs to be stripped off.  This is to\n   combat JSON hijacking.  If you're using JSON with GET request,\n   you should think about using this.\n   http://stackoverflow.com/questions/2669690/why-does-google-prepend-while1-to-their-json-responses\n   http://haacked.com/archive/2009/06/24/json-hijacking.aspx\"\n    (make-json-response-format \n        #? (:clj read-json-cheshire :cljs read-json-native)))\n\n(def json-request-format \n    (make-json-request-format \n        #? (:clj write-json-cheshire :cljs write-json-native)))\n"]}